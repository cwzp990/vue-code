# 响应式对象

**Object.defineProperty**

我们都知道 Vue 借助这个方法实现了双向绑定，通过这个函数可以监听到 get 和 set 的事件。

Vue 从 initState 函数开始，在 initialState 函数内部使用 initProps 函数初始化 props 属性，使用 initMethods 函数初始化 methods 属性，使用 initData 函数初始化 data 选项，使用 initComputed 函数和 initWatch 函数初始化 computed 和 watch 选项。

```js
if (opts.data) {
  initData(vm)
} else {
  observe((vm._data = {}), true /* asRootData */)
}
```

我们在 core/instance/state.js 目录下找到 initState 函数的定义

```js
let data = vm.$options.data // 这里的data还是函数
data = vm._data =
  typeof data === 'function' // 这里data变成了最终的数据对象
    ? getData(data, vm)
    : data || {}
```

这里的 data 经过 mergeOptions 函数处理后变成了一个函数。那这里为什么还要再进行一次判断呢？原因在于 beforeCreate 生命周期钩子函数是在 mergeOptions 函数之后 initData 之前被调用的，如果在这里修改了 vm.$options.data 的值，那么这里就有必要再进行一次判断了。

```js
export function getData(data: Function, vm: Component): any {
  // #7573 disable dep collection when invoking data getters
  pushTarget()
  try {
    return data.call(vm, vm) // 重点是这一句，通过调用data选项拿到数据对象
  } catch (e) {
    handleError(e, vm, `data()`)
    return {}
  } finally {
    popTarget()
  }
}
```

Vue 会循环遍历 props、data、methods 中的 key 值，如果有相同名字就会报错。如果没有会执行下面这句话

```js
if (!isReserved(key)) {
  proxy(vm, `_data`, key) // 代理，vm.key ---> vm._data.key
}
```

Vue 不会代理键名以$、\_开头的字段，因为这些是 Vue 内部的属性和方法，接着执行 proxy 函数：

```js
export function proxy(target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

该函数通过 object.defineProperty 函数在实例对象 vm 上定义与 data 数据字段同名的访问器属性，并且这些属性代理的值是 vm.\_data 上对应属性的值

```js
const ins = new Vue({
  data: {
    a: 1 // 在这里，我们访问ins.a，实际上是在访问ins._data.a
  }
})
```

经过一系列的处理之后，执行 observe(data, true /_ asRootData _/)，调用 observe 函数将 data 数据对象转换成响应式的

- 根据 vm.$options.data 选项获取真正想要的数据（注意：此时 vm.$options.data 是函数）
- 校验得到的数据是否是一个纯对象
- 检查数据对象 data 上的键是否与 props 对象上的键冲突
- 检查 methods 对象上的键是否与 data 对象上的键冲突
- 在 Vue 实例对象上添加代理访问数据对象的同名属性
- 最后调用 observe 函数开启响应式之路

```js
const ins = new Vue({
  data: {
    a: 1
  }
})

ins.$watch('a', () => {
  console.log('修改了 a')
})
```

要实现响应式这个功能，说复杂也复杂说简单也简单，复杂在于我们需要考虑的内容比较多，比如如何避免收集重复的依赖，如何深度观测，如何处理数组以及其他边界条件等等。简单在于如果不考虑那么多边界条件的话，要实现这样一个功能还是很容易的。这里我们就需要借助之前提到的 Object.defineProperty 这个方法了。

```js
Object.defineProperty(data, 'a', {
  set() {
    console.log('设置了属性 a')
  },
  get() {
    console.log('读取了属性 a')
  }
})
```

这样我们就实现了对属性 a 的设置和获取操作的拦截，这里我们在进一步，能不能在获取属性 a 的时候收集依赖，然后在设置属性 a 的时候触发之前收集的依赖呢？既然要收集依赖，我们至少需要一个容器吧，然后将所有收集到的依赖放入这个容器里，当属性被设置的时候，将容器里所有的依赖都拿出来执行就可以了。

```js
const dep = []
Object.defineProperty(data, 'a', {
  set() {
    // 当属性被设置的时候，将“筐”里的依赖都执行一次
    dep.forEach(fn => fn())
  },
  get() {
    // 当属性被获取的时候，把依赖放到“筐”里
    dep.push(fn)
  }
})
```

新的问题出现了，上述代码我们假设 fn 函数就是我们需要收集的依赖(observer)，但 fn 从何而来呢？也就是说如何在获取属性 a 的值时收集依赖呢？这个时候就需要在$watch 函数里做文章了。只有$watch 函数是知道当前正在观测的是哪一个字段的，所以我们需要在$watch 函数中读取该字段的值，从而触发字段的 get 函数，触发依赖收集。

```js
const data = {
  a: 1
}

const dep = []
Object.defineProperty(data, 'a', {
  set() {
    dep.forEach(fn => fn())
  },
  get() {
    // 此时 Target 变量中保存的就是依赖函数
    dep.push(Target)
  }
})

// Target 是全局变量
let Target = null
function $watch(exp, fn) {
  // 将 Target 的值设置为 fn
  Target = fn
  // 读取字段值，触发 get 函数
  data[exp]
}

// 我们在这里就实现了一个最基本的功能，但是还是有很多缺陷的，比如目前仅仅能够实现对a的观测，如果添加一个字段b呢？
$watch('a', () => {
  console.log('第一个依赖')
})
$watch('a', () => {
  console.log('第二个依赖')
})
```

让我们改进一下代码：

```js
for (let key in data) {
  const dep = []
  let val = data[key]
  Object.defineProperty(data, key, {
    get() {
      dep.push(target)
      return val
    },
    set(newVal) {
      if (newVal === val) return
      val = newVal
      dep.forEach(fn => fn())
    }
  })
}
```

然而上述代码遇到

```js
const data = {
  a: {
    b: 1
  }
}
```

这种情况就无能为力了。但是这个问题还是很好解决的，只需要重复递归定义即可。

```js
function walk(data) {
  for (let key in data) {
    const dep = []
    const val = data[key]
    const nativeString = Object.prototype.toString.call(val)
    if (nativeString === '[object Object]')
      Object.defineProperty(data, key, {
        get() {
          dep.push(Target)
          return val
        },
        set(newVal) {
          if ((newVal = val)) return
          val = newVal
          dep.forEach(fn => fn())
        }
      })
  }
}

walk(data)
```

我们思考一下$watch 函数的原理是什么？其实$watch 函数所做的事情就是想方设法地访问到你要观测的对象，从而触发该字段的 get 函数，进而收集依赖(观察者)。目前我们传递给$watch 函数的第一个参数是字符串，但可不可以是个函数呢，比如 render 函数？

```js
const data = {
  name: 'Tom'，
  age: 24
}

function render() {
  return document.write(`姓名:${data.name}，年龄:${data.age}`)
}
```

我们发现，render 函数依赖了数据对象 data，那么 render 函数是不是会触发 data.name 和 data.age 这两个字段的 get 拦截呢？答案是肯定的！上述代码中，第一个参数中 render 函数的执行使得我们能够收集依赖，当依赖变化后会重新执行第二个参数中的 render 函数，但是这又会触发一次数据段的 get 拦截器，所以总共会收集两次依赖...我们这里只是做了一个引子，下面我们正式进入 Vue 响应式原理~

##observe 工厂函数##

observe 函数在 core/observer/index.js 目录下

```js
export function observe(value: any, asRootData: ?boolean): Observer | void {
  // 第一个参数是接收的数据，第二个是是否是根级节点
  if (!isObject(value) || value instanceof VNode) {
    // 不是一个对象，不是VNode实例就返回
    return
  }
  let ob: Observer | void // 用ob来储存observe实例
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    // 数据没有_ob_说明没有观测过，避免重复观测一个对象
    ob = value.__ob__
  } else if (
    shouldObserve && // 相当于一个开关进行控制
    !isServerRendering() && // 服务器渲染
    (Array.isArray(value) || isPlainObject(value)) && // 数据对象必须是数组或对象
    Object.isExtensible(value) && // 数据对象必须是可扩展的
    !value._isVue // 避免Vue实例对象被观测
  ) {
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}
```

Observer 构造函数

```js
constructor (value: any) {
  this.value = value
  this.dep = new Dep()
  this.vmCount = 0
  def(value, '__ob__', this)              // def其实就是object.defineProperty的封装，且定义不可枚举属性
  if (Array.isArray(value)) {
    const augment = hasProto
      ? protoAugment
      : copyAugment
    augment(value, arrayMethods, arrayKeys)
    this.observeArray(value)
  } else {
    this.walk(value)                      // 循环遍历对象属性，并为每个属性调用defineReactive函数
  }
}
```

假设我们的数据对象如下：

```js
const data = {
  a: 1,
  // __ob__ 是不可枚举的属性
  __ob__: {
    value: data, // value 属性指向 data 数据对象本身，这是一个循环引用
    dep: dep实例对象, // new Dep()
    vmCount: 0
  }
}
```

我们来看看 defineReactive 函数都做了什么

```js
// 将数据对象的数据属性转换为访问器的属性，即为数据对象的属性设置一对getter/setter
export function defineReactive (
  obj: Object,                                            // 数据对象
  key: string,                                            // 属性键名
  val: any,
  customSetter?: ?Function,
  shallow?: boolean                                       // 是否是深度观测，一般不传，为true
                                                          // defineReactive(vm,'$attrs',...,null,true)  // 非深度观测
) {
  const dep = new Dep()                             // 这就是我们前面说的“筐”（收集依赖的容器）
                                                    // 每一个数据字段都通过闭包引用着属于自己的dep常量
                                                    const data = {
                                                      a:1,     ===>Dep
                                                      b:2      ===>Dep
                                                    }
                                                    // 每个字段的Dep对象都用来收集那些属于对应字段的依赖
  const property = Object.getOwnPropertyDescriptor(obj, key)    // 不可配置的属性是没必要使用Object.defineProperty
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property && property.get               // 缓存属性原有的getter/setter，不影响属性的原有读写操作
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {  // 只传递两个参数，如walk()..........(3)
    val = obj[key]
  }

  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // 省略...
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        // 这里闭包引用了上面的 dep 常量
        dep.depend()
        // 省略...
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      // 省略...

      // 这里闭包引用了上面的dep常量
      dep.notify()
    }
  })
}
```

数据对象经过了 observe 函数处理之后，变成了下面的样子：

```js
const data = {
  // 属性a通过getter/setter通过闭包引用着dep和childOb
  // 属性a闭包引用的childOb实际上就是data.a.__ob__
  a: {
    // 属性a通过getter/setter通过闭包引用着dep和childOb
    // 属性b闭包引用的childOb是undefined，因为属性b是基本类型，不是对象也不是数组
    b: 1;
    __ob__: {a,dep,vmCount}
  }
  __ob__: {a,dep,vmCount}
}
observe(data)
```

![observe](https://github.com/cwzp990/vue-code/tree/master/vue/images/observe1.png)

**getter 函数触发依赖收集**

```js
// 既然是getter，那么当然要能够正确访问属性值才行，依赖收集的时候就是属性被读取的时候
// getter做了两件事情：正确地返回属性值，以及依赖收集
get: function reactiveGetter() {
  const value = getter ? getter.call(obj) : val // getter保存的是属性原型的get函数，如果getter存在那么直接调用该函数
  // 不存在则使用val作为属性的值，最后将其返回，至此，getter第一步操作已完成了
  // 下面就是依赖收集的部分
  if (Dep.target) {
    // 此处的target保存的就是之前收集的依赖（观察者）
    dep.depend() // 这句就相当于依赖收集...........................................(1)
    // 将依赖收集到a自己的"筐"和data.a.__ob__.dep"筐"里
    // 第一个"筐"是dep：属性值被修改，set函数中的dep.notify()
    // 第二个"筐"是childOb.dep：使用$set或Vue.set给对象添加新属性时触发
    // js语言限制，在没有proxy之前，无法拦截到给对象添加属性的操作.......(2)
    if (childOb) {
      childOb.dep.depend()
      if (Array.isArray(value)) {
        dependArray(value)
      }
    }
  }
  return value
}
```

(1)
我们之前提到，访问器属性 a 的 getter/setter 通过闭包引用了一个 Dep 实例对象，即属性 a 用来收集依赖的"筐"，除此之外，访问器属性 a 的 setter/getter 还通过闭包引用着 childOb，且 childOb === data.a.__ob__，所以 childOb.dep === data.a.__ob__.dep

(2)
```js
Vue.set = function(obj, key, val) {
  defineReactive(obj, key, val)
  obj.__ob__.dep.notify() // 相当于 data.a.__ob__.dep.notify()
  // 添加、删除属性时有能力触发依赖
}

Vue.set(data.a, 'c', 1)
```

所以__ob__属性以及__ob__.dep的主要作用是为了添加删除属性时有能力触发依赖，而这就是Vue.set或Vue.delete的原理

(3)
**重点☆☆☆☆☆**
```js

// 之前的walk函数
walk (obj: Object) {
  const keys = Object.keys(obj)
  for (let i = 0; i < keys.length; i++) {
    // 这里传递了第三个参数
    defineReactive(obj, keys[i], obj[keys[i]])
  }
}

// 最新的walk函数
walk (obj: Object) {
  const keys = Object.keys(obj)
  for (let i = 0; i < keys.length; i++) {
    // 在 walk 函数中调用 defineReactive 函数时暂时不获取属性值
    defineReactive(obj, keys[i])
  }
}

// ================= 分割线 =================

// 在 defineReactive 函数内获取属性值
if (!getter && arguments.length === 2) {
  val = obj[key]
}

```

举个例子：

```js

const data = {
  getterProp: {
    a: 1
  }
}

new Vue({
  data,
  watch: {
    'getterProp.a': () => {
      console.log('这句话会输出')
    }
  }
})

```
这里的data是一个嵌套的对象，在watch选项中观察了属性getterProp.a，当我们修改了getterProp.a的值时，以上代码是能够正常输出的

```js

const data = {}
Object.defineProperty(data, 'getterProp', {
  enumerable: true,
  configurable: true,
  get: () => {
    return {
      a: 1
    }
  }
})

const ins = new Vue({
  data,
  watch: {
    'getterProp.a': () => {

```
此时，data.getterProp本身已经是一个访问器属性，且已经拥有get方法，当我们修改getterProp.a的值时，将不会输出，这是因为Vue发现

**setter 函数触发依赖**

```js

// 与get函数类似，set函数也要完成两个重要的事情，第一正确的为属性设置新值，第二能够触发相应的依赖
set: function reactiveSetter (newVal) {
  // 拿到原有的值和新值进行比较，当原值和新值不相等时才需要触发依赖和重新设置属性值
  const value = getter ? getter.call(obj) : val
  /* eslint-disable no-self-compare */
  // NaN === NaN......................false
  if (newVal === value || (newVal !== newVal && value !== value)) {
    return
  }
  /* eslint-enable no-self-compare */
  if (process.env.NODE_ENV !== 'production' && customSetter) {
    customSetter()                  // 用来打印辅助信息
  }
  if (setter) {                     // set常量用来存储原有的set函数
    setter.call(obj, newVal)
  } else {                          // 如果属性原本没有set函数，那么就设置val的值
    val = newVal
  }
  // 由于属性被设置了新值，我们需要对新值进行观测，这些都必须在需要深度观测的前提条件下才会执行
  childOb = !shallow && observe(newVal)
  dep.notify()
}


```