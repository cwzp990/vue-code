## 11. 组件的patch过程

前面我们知道，当我们通过createComponent创建了vnode，接下来会走到vm._update，执行vm._patch_去把vnode转换成真正的dom节点，那么组件vnode和普通vnode节点的转换过程有什么不同呢？

1. 了解组件patch的整体流程

在调用createComponent的方法时(创建组件vnode时),会执行componentVNodeHooks，也就是说，再执行patch时，有调用init，

```js

if (isDef(i = i.hook) && isDef(i = i.init)) {
  i(vnode, false /* hydrating */)
}

```

因此，就执行到了componentVNodeHooks里的init方法

```js

init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
  if (
    vnode.componentInstance &&
    !vnode.componentInstance._isDestroyed &&
    vnode.data.keepAlive
  ) {
    // kept-alive components, treat as a patch
    const mountedNode: any = vnode // work around flow
    componentVNodeHooks.prepatch(mountedNode, mountedNode)
  } else {
    const child = vnode.componentInstance = createComponentInstanceForVnode(
      vnode,
      activeInstance
    )
    child.$mount(hydrating ? vnode.elm : undefined, hydrating)
  }
},

```



2. 了解patch流程中的activeInstance、vm.$vnode、vm._vnode等

3. 了解嵌套组件的插入顺序

总结

+ oldVnode: 旧的虚拟节点或旧的真实dom节点
+ vnode: 新的虚拟节点
+ hydrating: 是否要跟真是dom混合
+ removeOnly: 特殊flag，用于<transition-group>组件
+ parentElm: 父节点
+ refElm: 新节点将插入到refElm之前

patch的策略：

1. 如果VNode不存在但是oldVNode存在，说明是要销毁老节点，调用invokeDestroyHook(oldVnode)来进行销毁
2. 如果oldVNode不存在但是VNode存在，说明是要创建新节点，调用createElm来创建新节点
3. VNode和oldVNode都存在：
   + 如果VNode和oldVNode是同一个节点
